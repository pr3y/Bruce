#include "hid_recorder.h"
#include "core/display.h"
#include "core/main_menu.h"
#include "core/mykeyboard.h"
#include "core/sd_functions.h"

#ifndef KB_HID_EXIT_MSG
#define KB_HID_EXIT_MSG "Exit"
#endif

extern void ducky_chooseKb(HIDInterface *&hid, bool ble);

void flush_pending_string(String &pending_string, String &duckyscript) {
    if (pending_string.length() > 0) {
        duckyscript += "STRING " + pending_string + "\n";
        pending_string = "";
    }
}

String clean_duckyscript(const String &original_script) {
    String cleaned = "";
    int start = 0;
    int removed_count = 0;

    while (start < original_script.length()) {
        int end = original_script.indexOf('\n', start);
        if (end == -1) end = original_script.length();

        String line = original_script.substring(start, end);
        line.trim();

        bool is_ghost_line = false;

        if (line.indexOf("GUI F") >= 0 || line.indexOf("CTRL F") >= 0 || line.indexOf("ALT F") >= 0 ||
            line.startsWith("F1") || line.startsWith("F2") || line.startsWith("F3") ||
            line.startsWith("F4") || line.startsWith("F5") || line.startsWith("F6") ||
            line.startsWith("F7") || line.startsWith("F8") || line.startsWith("F9") ||
            line.startsWith("F10") || line.startsWith("F11") || line.startsWith("F12")) {

            is_ghost_line = true;
            removed_count++;
        }

        if (!is_ghost_line && line.length() > 0) { cleaned += line + "\n"; }

        start = end + 1;
    }

    return cleaned;
}

// Main function - record keys WITH HID sending
void ducky_recorder(HIDInterface *&hid, bool ble = false) {
    keyStroke key;
    unsigned long debounce = millis();
    String _mymsg = "";
    String duckyscript = "";    // Store the script
    String pending_string = ""; // Buffer to group consecutive characters

    // Reset returnToMenu
    returnToMenu = false;

    Serial.printf("HID Recorder: Starting recording... (BLE: %d)\n", ble);

    drawMainBorder();
    tft.setTextSize(FM);
    tft.setTextColor(bruceConfig.priColor);
    tft.drawString("HID Recorder Active", tftWidth / 2, tftHeight / 2 - 10);
    tft.drawString("Recording & Sending", tftWidth / 2, tftHeight / 2 + 10);

    tft.setTextColor(bruceConfig.priColor, bruceConfig.bgColor);
    tft.setTextSize(FP);
    drawMainBorder();
    tft.setCursor(10, 28);
    tft.println("Recording & Sending Keys:");
    tft.setCursor(10, 38);
    tft.println("Live HID + DuckScript");
    tft.drawCentreString("> " + String(KB_HID_EXIT_MSG) + " <", tftWidth / 2, tftHeight - 20, 1);
    tft.setTextSize(FM);

    duckyscript += "REM Generated by Bruce HID Recorder\n";
    duckyscript += "REM Mode: Live HID + Recording\n";
    duckyscript += "DELAY 1000\n";

    while (1) {
#if defined(HAS_KEYBOARD)
        key = _getKeyPress();
        if (key.pressed && (millis() - debounce > 500)) {
            String ducky_line = "";

            if (key.fn && key.exit_key) {
                break;
            }

            if (key.enter) {
                flush_pending_string(pending_string, duckyscript);
                ducky_line = "ENTER";
            } else if (key.del) {
                flush_pending_string(pending_string, duckyscript);
                ducky_line = "BACKSPACE";
            } else if (key.word.size() > 0 || key.modifier_keys.size() > 0) {
                bool is_valid_input = true;

                if (key.word.size() == 0 && key.modifier_keys.size() > 0) {
                    if (key.ctrl || key.alt || key.gui) {
                        is_valid_input = true;
                    } else {
                        auto k = key.modifier_keys[0];
                        if (!(k >= 0x28 && k <= 0x2F) && !(k >= 0x4F && k <= 0x52) &&
                            !(k >= 0x3A && k <= 0x45)) {
                            is_valid_input = false;
                        }
                    }
                }

                if (!is_valid_input) {
                    debounce = millis();
                    continue;
                }

                String modifiers = "";
                if (key.ctrl) modifiers += "CTRL ";
                if (key.alt) modifiers += "ALT ";
                if (key.gui) modifiers += "GUI ";

                if (key.word.size() > 0) {
                    String text = "";
                    for (char k : key.word) {
                        text += k;
                    }

                    if (modifiers.length() > 0) {
                        flush_pending_string(pending_string, duckyscript);

                        if (text.length() == 1) {
                            if (text[0] == ' ') {
                                ducky_line = modifiers + "SPACE";
                            } else {
                                ducky_line = modifiers + text;
                            }
                        } else {
                            for (char c : text) {
                                if (ducky_line.length() > 0) ducky_line += "\n";
                                if (c == ' ') {
                                    ducky_line += modifiers + "SPACE";
                                } else {
                                    ducky_line += modifiers + String(c);
                                }
                            }
                        }
                    } else {
                        pending_string += text;
                        ducky_line = "";
                    }
                }

                for (auto k : key.modifier_keys) {
                    flush_pending_string(pending_string, duckyscript);

                    if (ducky_line.length() > 0) ducky_line += "\n";
                    if (modifiers.length() > 0) {
                        if (k >= 0x80 && k <= 0x8B) {
                            ducky_line += modifiers + "F" + String(k - 0x79);
                        } else if (k == 0x20) {
                            ducky_line += modifiers + "SPACE";
                        } else {
                            ducky_line += modifiers + String((char)k);
                        }
                    } else {
                        if (k >= 0x80 && k <= 0x8B) {
                            ducky_line += "F" + String(k - 0x79);
                        } else if (k == 0x20) {
                            ducky_line += "SPACE";
                        } else {
                            ducky_line += "KEY " + String((char)k);
                        }
                    }
                }
            }

            if (ducky_line.length() > 0) {
                duckyscript += ducky_line + "\n";
            }

            if (key.alt) hid->press(KEY_LEFT_ALT);
            if (key.ctrl) hid->press(KEY_LEFT_CTRL);
            if (key.gui) hid->press(KEY_LEFT_GUI);
            if (key.enter) {
                hid->println();
            } else if (key.del) {
                hid->press(KEYBACKSPACE);
            } else {
                for (char k : key.word) {
                    hid->press(k);
                }
                for (auto k : key.modifier_keys) {
                    hid->press(k);
                }
            }

            hid->releaseAll();

            String keyStr = "";
            for (auto i : key.word) {
                if (keyStr != "") {
                    keyStr = keyStr + "+" + i;
                } else {
                    keyStr += i;
                }
            }

            if (keyStr.length() > 0) {
                drawMainBorder(false);
                if (_mymsg.length() > keyStr.length())
                    tft.drawCentreString("                                  ", tftWidth / 2, tftHeight / 2, 1);
                tft.drawCentreString("Sent: " + keyStr, tftWidth / 2, tftHeight / 2, 1);
                _mymsg = keyStr;
            }
            debounce = millis();
        }
#endif

        if (check(EscPress)) {
            break;
        }
        if (returnToMenu) {
            break;
        }
    }

    flush_pending_string(pending_string, duckyscript);
    String cleaned_script = clean_duckyscript(duckyscript);

    // Save file at the end
    if (cleaned_script.length() > 50) {
        String filename = keyboard("", 20, "recorded");
        if (filename.length() > 0) {
            if (setupSdCard()) {
                String fullPath = "/" + filename + ".txt";
                File file = SD.open(fullPath, "w");
                if (file) {
                    size_t bytesWritten = file.print(cleaned_script);
                    file.close();
                    displayWarning("Saved to SD: " + filename + ".txt (" + String(bytesWritten) + " bytes)", false);
                    delay(3000);
                } else {
                    File file2 = LittleFS.open("/" + filename + ".txt", "w");
                    if (file2) {
                        size_t bytesWritten = file2.print(cleaned_script);
                        file2.close();
                        displayWarning("Saved to LittleFS: " + filename + ".txt (" + String(bytesWritten) + " bytes)", false);
                        delay(3000);
                    } else {
                        displayWarning("Save failed on both SD and LittleFS!", false);
                        delay(2000);
                    }
                }
            } else {
                File file = LittleFS.open("/" + filename + ".txt", "w");
                if (file) {
                    size_t bytesWritten = file.print(cleaned_script);
                    file.close();
                    displayWarning("Saved to LittleFS: " + filename + ".txt", false);
                    delay(2000);
                } else {
                    displayWarning("Save failed!", false);
                    delay(2000);
                }
            }
        } else {
            Serial.println("HID Recorder: Empty filename, not saving");
        }
    } else {
        Serial.printf(
            "HID Recorder: Insufficient content to save (%d clean characters)\n", cleaned_script.length()
        );
        displayWarning("Nothing to save", false);
        delay(1500);
    }
}

// Setup function for menu use - exact copy of ducky_setup
void hid_recorder_setup() {
    HIDInterface *hid = nullptr;
    bool ble = false;

    Serial.println("HID Recorder Setup: Starting...");

    // Initialize file systems
    if (!LittleFS.begin()) {
        Serial.println("HID Recorder: Failed to initialize LittleFS");
    } else {
        Serial.println("HID Recorder: LittleFS initialized successfully");
    }

    // Try to initialize SD Card
    if (setupSdCard()) {
        Serial.println("HID Recorder: SD Card initialized successfully");
    } else {
        Serial.println("HID Recorder: SD Card not available, using LittleFS");
    }

    // Reset returnToMenu before starting
    returnToMenu = false;

    Serial.println("HID Recorder Setup: returnToMenu reset");

    // Choose between USB and BLE first
    options = {
        {"USB HID",
         [&]() {
             Serial.println("HID Recorder Setup: Selected USB HID");
             ble = false;
         }                   },
        {"BLE HID", [&]() {
             Serial.println("HID Recorder Setup: Selected BLE HID");
             ble = true;
         }},
    };

    Serial.println("HID Recorder Setup: Calling loopOptions...");
    loopOptions(options, MENU_TYPE_SUBMENU, "HID Recorder");

    Serial.printf("HID Recorder Setup: After loopOptions - returnToMenu=%d, ble=%d\n", returnToMenu, ble);

    if (returnToMenu) {
        Serial.println("HID Recorder Setup: Exiting by returnToMenu");
        return;
    }

    Serial.println("HID Recorder Setup: Continuing to ducky_chooseKb...");

    // Reset returnToMenu before choosing layout
    returnToMenu = false;

    // Use ducky_chooseKb to choose layout and initialize HID
    // This function will create and configure the hid appropriately
    ducky_chooseKb(hid, ble);

    Serial.printf("HID Recorder Setup: After ducky_chooseKb - returnToMenu=%d, hid=%p\n", returnToMenu, hid);

    if (returnToMenu) {
        Serial.println("HID Recorder Setup: Exiting after ducky_chooseKb");
        return;
    }

    if (hid == nullptr) {
        Serial.println("HID Recorder Setup: Error - hid is still nullptr after ducky_chooseKb");
        return;
    }

    Serial.println("HID Recorder Setup: Starting recording...");

    // Reset returnToMenu before starting recording
    returnToMenu = false;

    // Disconnect HID to not send commands during recording
    if (ble) {
        // For BLE, we can stop the connection
        if (hid->isConnected()) {
            Serial.println("HID Recorder Setup: Disconnecting BLE...");
            // Note: We won't disconnect completely, just won't send commands
        }
    } else {
        // For USB HID, we'll just not send commands
        Serial.println("HID Recorder Setup: USB HID configured (record-only mode)");
    }

    // Start recording
    ducky_recorder(hid, ble);
}
