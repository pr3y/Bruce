#include "hid_recorder.h"
#include "core/display.h"
#include "core/main_menu.h"
#include "core/mykeyboard.h"
#include "core/sd_functions.h"

#ifndef KB_HID_EXIT_MSG
#define KB_HID_EXIT_MSG "Exit"
#endif

extern void ducky_chooseKb(HIDInterface *&hid, bool ble);

void flush_pending_string(String &pending_string, String &duckyscript) {
    if (pending_string.length() > 0) {
        duckyscript += "STRING " + pending_string + "\n";
        pending_string = "";
    }
}

String clean_duckyscript(const String &original_script) {
    String cleaned = "";
    int start = 0;
    int removed_count = 0;

    while (start < original_script.length()) {
        int end = original_script.indexOf('\n', start);
        if (end == -1) end = original_script.length();

        String line = original_script.substring(start, end);
        line.trim();

        bool is_ghost_line = false;

        if (line.indexOf("GUI F") >= 0 || line.indexOf("CTRL F") >= 0 || line.indexOf("ALT F") >= 0 ||
            line.startsWith("F1") || line.startsWith("F2") || line.startsWith("F3") ||
            line.startsWith("F4") || line.startsWith("F5") || line.startsWith("F6") ||
            line.startsWith("F7") || line.startsWith("F8") || line.startsWith("F9") ||
            line.startsWith("F10") || line.startsWith("F11") || line.startsWith("F12")) {

            is_ghost_line = true;
            removed_count++;
        }

        if (!is_ghost_line && line.length() > 0) { cleaned += line + "\n"; }

        start = end + 1;
    }

    return cleaned;
}

// Função principal - gravação de teclas COM envio HID
void ducky_recorder(HIDInterface *&hid, bool ble = false) {
    keyStroke key;
    unsigned long debounce = millis();
    String _mymsg = "";
    String duckyscript = "";    // Armazenar o script
    String pending_string = ""; // Buffer para agrupar caracteres consecutivos

    // Resetar returnToMenu
    returnToMenu = false;

    Serial.printf("HID Recorder: Iniciando gravação... (BLE: %d)\n", ble);

    drawMainBorder();
    tft.setTextSize(FM);
    tft.setTextColor(bruceConfig.priColor);
    tft.drawString("HID Recorder Active", tftWidth / 2, tftHeight / 2 - 10);
    tft.drawString("Recording & Sending", tftWidth / 2, tftHeight / 2 + 10);

    tft.setTextColor(bruceConfig.priColor, bruceConfig.bgColor);
    tft.setTextSize(FP);
    drawMainBorder();
    tft.setCursor(10, 28);
    tft.println("Recording & Sending Keys:");
    tft.setCursor(10, 38);
    tft.println("Live HID + DuckScript");
    tft.drawCentreString("> " + String(KB_HID_EXIT_MSG) + " <", tftWidth / 2, tftHeight - 20, 1);
    tft.setTextSize(FM);

    duckyscript += "REM Generated by Bruce HID Recorder\n";
    duckyscript += "REM Mode: Live HID + Recording\n";
    duckyscript += "DELAY 1000\n";

    while (1) {
#if defined(HAS_KEYBOARD)
        key = _getKeyPress();
        if (key.pressed && (millis() - debounce > 500)) {
            String ducky_line = "";

            if (key.fn && key.exit_key) {
                break;
            }

            if (key.enter) {
                flush_pending_string(pending_string, duckyscript);
                ducky_line = "ENTER";
            } else if (key.del) {
                flush_pending_string(pending_string, duckyscript);
                ducky_line = "BACKSPACE";
            } else if (key.word.size() > 0 || key.modifier_keys.size() > 0) {
                bool is_valid_input = true;

                if (key.word.size() == 0 && key.modifier_keys.size() > 0) {
                    if (key.ctrl || key.alt || key.gui) {
                        is_valid_input = true;
                    } else {
                        auto k = key.modifier_keys[0];
                        if (!(k >= 0x28 && k <= 0x2F) && !(k >= 0x4F && k <= 0x52) &&
                            !(k >= 0x3A && k <= 0x45)) {
                            is_valid_input = false;
                        }
                    }
                }

                if (!is_valid_input) {
                    debounce = millis();
                    continue;
                }

                String modifiers = "";
                if (key.ctrl) modifiers += "CTRL ";
                if (key.alt) modifiers += "ALT ";
                if (key.gui) modifiers += "GUI ";

                if (key.word.size() > 0) {
                    String text = "";
                    for (char k : key.word) {
                        text += k;
                    }

                    if (modifiers.length() > 0) {
                        flush_pending_string(pending_string, duckyscript);

                        if (text.length() == 1) {
                            if (text[0] == ' ') {
                                ducky_line = modifiers + "SPACE";
                            } else {
                                ducky_line = modifiers + text;
                            }
                        } else {
                            for (char c : text) {
                                if (ducky_line.length() > 0) ducky_line += "\n";
                                if (c == ' ') {
                                    ducky_line += modifiers + "SPACE";
                                } else {
                                    ducky_line += modifiers + String(c);
                                }
                            }
                        }
                    } else {
                        pending_string += text;
                        ducky_line = "";
                    }
                }

                for (auto k : key.modifier_keys) {
                    flush_pending_string(pending_string, duckyscript);

                    if (ducky_line.length() > 0) ducky_line += "\n";
                    if (modifiers.length() > 0) {
                        if (k >= 0x80 && k <= 0x8B) {
                            ducky_line += modifiers + "F" + String(k - 0x79);
                        } else if (k == 0x20) {
                            ducky_line += modifiers + "SPACE";
                        } else {
                            ducky_line += modifiers + String((char)k);
                        }
                    } else {
                        if (k >= 0x80 && k <= 0x8B) {
                            ducky_line += "F" + String(k - 0x79);
                        } else if (k == 0x20) {
                            ducky_line += "SPACE";
                        } else {
                            ducky_line += "KEY " + String((char)k);
                        }
                    }
                }
            }

            if (ducky_line.length() > 0) {
                duckyscript += ducky_line + "\n";
            }

            if (key.alt) hid->press(KEY_LEFT_ALT);
            if (key.ctrl) hid->press(KEY_LEFT_CTRL);
            if (key.gui) hid->press(KEY_LEFT_GUI);
            if (key.enter) {
                hid->println();
            } else if (key.del) {
                hid->press(KEYBACKSPACE);
            } else {
                for (char k : key.word) {
                    hid->press(k);
                }
                for (auto k : key.modifier_keys) {
                    hid->press(k);
                }
            }

            hid->releaseAll();

            String keyStr = "";
            for (auto i : key.word) {
                if (keyStr != "") {
                    keyStr = keyStr + "+" + i;
                } else {
                    keyStr += i;
                }
            }

            if (keyStr.length() > 0) {
                drawMainBorder(false);
                if (_mymsg.length() > keyStr.length())
                    tft.drawCentreString("                                  ", tftWidth / 2, tftHeight / 2, 1);
                tft.drawCentreString("Sent: " + keyStr, tftWidth / 2, tftHeight / 2, 1);
                _mymsg = keyStr;
            }
            debounce = millis();
        }
#endif

        if (check(EscPress)) {
            break;
        }
        if (returnToMenu) {
            break;
        }
    }

    flush_pending_string(pending_string, duckyscript);
    String cleaned_script = clean_duckyscript(duckyscript);

    // Salvar arquivo no final
    if (cleaned_script.length() > 50) {
        String filename = keyboard("", 20, "recorded");
        if (filename.length() > 0) {
            if (setupSdCard()) {
                String fullPath = "/" + filename + ".txt";
                File file = SD.open(fullPath, "w");
                if (file) {
                    size_t bytesWritten = file.print(cleaned_script);
                    file.close();
                    displayWarning("Saved to SD: " + filename + ".txt (" + String(bytesWritten) + " bytes)", false);
                    delay(3000);
                } else {
                    File file2 = LittleFS.open("/" + filename + ".txt", "w");
                    if (file2) {
                        size_t bytesWritten = file2.print(cleaned_script);
                        file2.close();
                        displayWarning("Saved to LittleFS: " + filename + ".txt (" + String(bytesWritten) + " bytes)", false);
                        delay(3000);
                    } else {
                        displayWarning("Save failed on both SD and LittleFS!", false);
                        delay(2000);
                    }
                }
            } else {
                File file = LittleFS.open("/" + filename + ".txt", "w");
                if (file) {
                    size_t bytesWritten = file.print(cleaned_script);
                    file.close();
                    displayWarning("Saved to LittleFS: " + filename + ".txt", false);
                    delay(2000);
                } else {
                    displayWarning("Save failed!", false);
                    delay(2000);
                }
            }
        } else {
            Serial.println("HID Recorder: Nome de arquivo vazio, não salvando");
        }
    } else {
        Serial.printf(
            "HID Recorder: Conteúdo insuficiente para salvar (%d caracteres limpos)\n",
            cleaned_script.length()
        );
        displayWarning("Nothing to save", false);
        delay(1500);
    }
}

// Função de setup para usar no menu - cópia exata do ducky_setup
void hid_recorder_setup() {
    HIDInterface *hid = nullptr;
    bool ble = false;

    Serial.println("HID Recorder Setup: Iniciando...");

    // Inicializar sistemas de arquivos
    if (!LittleFS.begin()) {
        Serial.println("HID Recorder: Falha ao inicializar LittleFS");
    } else {
        Serial.println("HID Recorder: LittleFS inicializado com sucesso");
    }

    // Tentar inicializar SD Card
    if (setupSdCard()) {
        Serial.println("HID Recorder: SD Card inicializado com sucesso");
    } else {
        Serial.println("HID Recorder: SD Card não disponível, usando LittleFS");
    }

    // Resetar returnToMenu antes de começar
    returnToMenu = false;

    Serial.println("HID Recorder Setup: returnToMenu resetado");

    // Escolher entre USB e BLE primeiro
    options = {
        {"USB HID",
         [&]() {
             Serial.println("HID Recorder Setup: Selecionou USB HID");
             ble = false;
         }                   },
        {"BLE HID", [&]() {
             Serial.println("HID Recorder Setup: Selecionou BLE HID");
             ble = true;
         }},
    };

    Serial.println("HID Recorder Setup: Chamando loopOptions...");
    loopOptions(options, MENU_TYPE_SUBMENU, "HID Recorder");

    Serial.printf("HID Recorder Setup: Após loopOptions - returnToMenu=%d, ble=%d\n", returnToMenu, ble);

    if (returnToMenu) {
        Serial.println("HID Recorder Setup: Saindo por returnToMenu");
        return;
    }

    Serial.println("HID Recorder Setup: Continuando para ducky_chooseKb...");

    // Resetar returnToMenu antes de escolher layout
    returnToMenu = false;

    // Usar ducky_chooseKb para escolher layout e inicializar HID
    // Esta função vai criar e configurar o hid apropriadamente
    ducky_chooseKb(hid, ble);

    Serial.printf("HID Recorder Setup: Após ducky_chooseKb - returnToMenu=%d, hid=%p\n", returnToMenu, hid);

    if (returnToMenu) {
        Serial.println("HID Recorder Setup: Saindo após ducky_chooseKb");
        return;
    }

    if (hid == nullptr) {
        Serial.println("HID Recorder Setup: Erro - hid ainda é nullptr após ducky_chooseKb");
        return;
    }

    Serial.println("HID Recorder Setup: Iniciando gravação...");

    // Resetar returnToMenu antes de iniciar gravação
    returnToMenu = false;

    // Desconectar o HID para não enviar comandos durante a gravação
    if (ble) {
        // Para BLE, podemos parar a conexão
        if (hid->isConnected()) {
            Serial.println("HID Recorder Setup: Desconectando BLE...");
            // Note: Não vamos desconectar completamente, apenas não enviaremos comandos
        }
    } else {
        // Para USB HID, vamos apenas não enviar comandos
        Serial.println("HID Recorder Setup: USB HID configurado (modo somente gravação)");
    }

    // Iniciar gravação
    ducky_recorder(hid, ble);
}
